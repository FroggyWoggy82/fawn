{% extends 'meals/base.html' %}
{% load static %}
{% load time_filters %}

{% block title %}WIR Page{% endblock %}

{% block style %}
<style>
    h1, h2 {
        text-align: center;
        color: #333;
    }
    
    /* Page layout */
    body {
        margin: 0;
        padding: 0;
    }
    
    /* Main container layout */
    .wir-container {
        display: flex;
        justify-content: center;
        gap: 30px;
        margin: 20px auto;
        max-width: 1000px;
    }
    
    /* Task priorities section */
    .task-priorities-container {
        width: 250px;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 10px;
        background-color: white;
        margin-right: 30px;
        align-self: flex-start;
    }
    
    /* Task creation row */
    .task-creation {
        display: flex;
        margin-bottom: 15px;
        width: 100%;
        box-sizing: border-box;
    }
    
    /* Input field */
    #new-task-title {
        flex: 1;
        margin-right: 5px;
    }
    
    /* Priority dropdown */
    #task-priority {
        margin-right: 5px;
        width: auto;
    }
    
    /* Add button */
    #add-task-btn {
        min-width: 45px;
    }
    
    /* Center column for timer and content */
    .timer-column {
        width: 600px;
    }
    
    @media (max-width: 900px) {
        .wir-container {
            flex-direction: column;
            align-items: center;
        }
        
        .task-priorities-container {
            width: 100%;
            max-width: 600px;
            margin-right: 0;
            margin-bottom: 20px;
        }
        
        .timer-column {
            width: 100%;
            max-width: 600px;
        }
    }
    
    /* Task priority management styles */
    .priority-management {
        width: 100%;
        box-sizing: border-box;
    }
    
    .task-creation input {
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        box-sizing: border-box;
    }
    
    .task-creation select {
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        box-sizing: border-box;
    }
    
    .priority-section {
        margin-bottom: 15px;
        padding: 12px;
        border-radius: 6px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        width: 100%;
        box-sizing: border-box;
    }
    
    .high-priority {
        background-color: #ffebee;
        border-left: 4px solid #f44336;
    }
    
    .medium-priority {
        background-color: #fff8e1;
        border-left: 4px solid #ffc107;
    }
    
    .low-priority {
        background-color: #e1f5fe;
        border-left: 4px solid #03a9f4;
    }

    .priority-section h4 {
        margin-top: 0;
        color: #333;
        border-bottom: 1px solid rgba(0,0,0,0.1);
        padding-bottom: 5px;
    }
    
    .task-item {
        background-color: white;
        padding: 8px 12px;
        margin: 6px 0;
        border-radius: 4px;
        box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        transition: all 0.2s ease;
        cursor: pointer;
        position: relative;
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        box-sizing: border-box;
    }

    .task-item.selected-task {
        background-color: #e3f2fd;
        border-left: 3px solid #2196f3;
        padding-left: 9px; /* Account for the border */
        font-weight: 500;
    }
    
    .task-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    /* Comparison modal styles */
    .comparison-modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
    }
    
    .modal-content {
        background-color: white;
        margin: 15% auto;
        padding: 20px;
        border-radius: 8px;
        width: 80%;
        max-width: 500px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        text-align: center;
    }
    
    .comparison-tasks {
        display: flex;
        justify-content: space-between;
        margin: 20px 0;
    }
    
    .comparison-task {
        flex: 1;
        padding: 15px;
        margin: 0 10px;
        background-color: #f8f9fa;
        border-radius: 4px;
        font-weight: bold;
    }
    
    .comparison-buttons {
        display: flex;
        justify-content: space-between;
        gap: 10px;
    }
    
    .comparison-buttons button {
        flex: 1;
        padding: 10px 15px;
        border: none;
        border-radius: 4px;
        background-color: #007bff;
        color: white;
        cursor: pointer;
        transition: background-color 0.3s;
    }
    
    .comparison-buttons button:hover {
        background-color: #0056b3;
    }
    
    /* Original WIR styles */
    form {
        text-align: center;
        background: #fff;
        padding: 20px;
        margin: 0 auto 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        border-radius: 8px;
        width: 100%;
        max-width: 600px;
        box-sizing: border-box;
    }
    .timer {
        font-size: 2.5em;
        margin: 20px 0;
        font-weight: bold;
        color: #007bff;
    }
    .button {
        padding: 10px 20px;
        margin: 5px;
        background: #007bff;
        color: #fff;
        border: none;
        cursor: pointer;
        border-radius: 5px;
        transition: background-color 0.3s, transform 0.2s;
    }
    .button:hover {
        background: #0056b3;
        transform: translateY(-2px);
    }
    .button:disabled {
        background: #ccc;
        cursor: not-allowed;
        transform: none;
    }
    .task-container {
        position: relative;
        padding-bottom: 20px;
        width: 100%;
    }
    .task-title {
        font-size: 1.2em;
        font-weight: bold;
        margin-bottom: 10px;
    }
    .subtask-container {
        display: none;
        background: #e9f5ff;
        padding: 20px;
        border-radius: 8px;
        margin-top: 20px;
        border-left: 4px solid #007bff;
        width: 100%;
        box-sizing: border-box;
    }
    .subtask-timer {
        font-size: 2em;
        margin: 15px 0;
        color: #0056b3;
        font-weight: bold;
    }
    .subtask-title {
        font-size: 1.1em;
        font-weight: bold;
        color: #0056b3;
    }
    .subtask-list {
        margin-top: 20px;
        display: none;
        width: 100%;
    }
    .subtask-list h3 {
        margin-bottom: 10px;
        color: #007bff;
        border-bottom: 1px solid #ccc;
        padding-bottom: 5px;
    }
    .subtask-item {
        background: #fff;
        padding: 12px;
        margin: 8px 0;
        border-radius: 5px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        transition: transform 0.2s;
        width: 100%;
        box-sizing: border-box;
    }
    .subtask-item:hover {
        transform: translateX(5px);
    }
    .subtask-item .subtask-name {
        font-weight: 500;
    }
    .subtask-item .subtask-duration {
        color: #007bff;
        font-weight: bold;
    }
    .metrics, .task-list {
        text-align: center;
        margin: 20px auto;
        background: #fff;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        max-width: 600px;
        width: 100%;
        box-sizing: border-box;
    }
    .task-list ul {
        list-style: none;
        padding: 0;
        text-align: left;
        width: 100%;
    }
    .task-list li {
        background: #f9f9f9;
        margin: 10px auto;
        padding: 15px;
        border-radius: 5px;
        border-left: 4px solid #007bff;
        transition: transform 0.2s;
        width: 100%;
        box-sizing: border-box;
    }
    .task-list li:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .task-details {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
    }
    .task-title-display {
        font-weight: bold;
        font-size: 1.1em;
    }
    .task-duration {
        color: #007bff;
        font-weight: bold;
    }
    .subtasks-section {
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px dashed #ccc;
        font-size: 0.9em;
        display: none;
        width: 100%;
        box-sizing: border-box;
    }
    .subtasks-section.has-subtasks {
        display: block;
    }
    .subtasks-section h4 {
        margin: 5px 0;
        color: #555;
    }
    .subtasks-section ul.subtasks-list {
        display: none;
        margin-top: 5px;
        width: 100%;
        padding-left: 0;
    }
    .subtasks-section li {
        background: #f0f0f0;
        border-left: 3px solid #0056b3;
        margin: 5px 0;
        padding: 8px;
        width: 100%;
        box-sizing: border-box;
    }
    .home-button {
        display: block;
        width: 200px;
        margin: 20px auto;
        padding: 10px;
        background-color: #4CAF50;
        color: white;
        text-align: center;
        text-decoration: none;
        border-radius: 5px;
        font-weight: bold;
        transition: background-color 0.3s;
    }
    .home-button:hover {
        background-color: #45a049;
    }
    .active-task-indicator {
        position: absolute;
        top: -10px;
        right: -10px;
        background: #28a745;
        color: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        display: none;
    }
    .active-task-indicator.active {
        display: flex;
    }
    .toggle-subtasks-btn {
        background: none;
        border: none;
        color: #007bff;
        cursor: pointer;
        font-size: 0.9em;
        margin-left: 10px;
        padding: 2px 5px;
        border-radius: 3px;
    }
    .toggle-subtasks-btn:hover {
        background-color: #e9f5ff;
        text-decoration: underline;
    }
    .subtasks-visible {
        display: block !important;
    }
    .nested-subtask {
        margin-top: 0;
        background: #e3f0ff;
        border-left: 4px solid #0056b3;
        display: none;
        width: 100%;
        box-sizing: border-box;
    }
    .task-hierarchy {
        margin-left: 20px;
    }
    .parent-task {
        font-weight: bold;
    }
    .nested-subtasks-list {
        margin-top: 5px;
        margin-left: 20px;
        padding-left: 0;
        list-style-type: none;
        width: 100%;
        box-sizing: border-box;
    }
    .nested-subtask-item {
        background-color: #f0f8ff;
        padding: 6px 8px;
        margin: 4px 0;
        border-left: 2px solid #4682b4;
        border-radius: 3px;
        font-size: 0.95em;
        width: 100%;
        box-sizing: border-box;
    }
    .nested-indicator {
        color: #4682b4;
        font-weight: bold;
        margin-right: 5px;
    }
    .formatted-time {
        font-weight: bold;
        color: #007bff;
        font-size: 1.2em;
    }
    .nested-subtask-item-deep {
        background-color: #e6f2ff;
        padding: 6px 8px 6px 15px;
        margin: 4px 0;
        border-left: 2px solid #6495ed;
        border-radius: 3px;
        font-size: 0.9em;
        width: 100%;
        box-sizing: border-box;
    }
    .nested-subtasks-list-deep {
        margin-top: 5px;
        margin-left: 15px;
        padding-left: 0;
        list-style-type: none;
        width: 100%;
        box-sizing: border-box;
    }
    
    /* Styling for priority lists */
    #high-priority-tasks, #medium-priority-tasks, #low-priority-tasks {
        padding-left: 0;
        margin-top: 10px;
        width: 100%;
        box-sizing: border-box;
    }
    
    .priority-title {
        font-size: 14px;
        font-weight: 600;
        margin-bottom: 10px;
        color: #333;
    }

    .delete-task {
        color: #e57373 !important;
        cursor: pointer;
        padding: 4px;
        border-radius: 50%;
        height: 16px;
        width: 16px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        margin-left: 8px;
        opacity: 0.7;
        transition: opacity 0.2s;
    }

    .delete-task:hover {
        opacity: 1;
        background-color: #ffebee;
    }

    #new-task-title {
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
        box-sizing: border-box;
    }

    #task-priority {
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
        box-sizing: border-box;
    }

    #add-task-btn {
        padding: 8px 12px;
        background-color: #2196f3;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s;
        white-space: nowrap;
        box-sizing: border-box;
    }

    #add-task-btn:hover {
        background-color: #1976d2;
    }
</style>
{% endblock %}
{% block content %}
    <h1>WIR Page</h1>
    
    <div class="wir-container">
        <!-- Left Column: Priority Task Management -->
        <div class="priority-column">
            <div class="priority-management">
                <h3 class="priority-title">Task Priorities</h3>
                
                <!-- Task Creation Form -->
                <div class="task-creation">
                    <input type="text" id="new-task-title" placeholder="New task title..." required>
                    <select id="task-priority">
                        <option value="high">High</option>
                        <option value="medium">Medium</option>
                        <option value="low">Low</option>
                    </select>
                    <button type="button" id="add-task-btn" class="button">Add</button>
                </div>
                
                <!-- Priority Lists -->
                <div class="priority-lists">
                    <div class="priority-section high-priority">
                        <h4>High Priority</h4>
                        <ul id="high-priority-tasks"></ul>
                    </div>
                    
                    <div class="priority-section medium-priority">
                        <h4>Medium Priority</h4>
                        <ul id="medium-priority-tasks"></ul>
                    </div>
                    
                    <div class="priority-section low-priority">
                        <h4>Low Priority</h4>
                        <ul id="low-priority-tasks"></ul>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Right Column: Task Timer (Original Content) -->
        <div class="timer-column">
            <!-- Task Form with Timer -->
            <form method="post" id="taskForm" action="{% url 'wir_view' %}">
                {% csrf_token %}
                <div class="task-container">
                    <div class="active-task-indicator" id="mainTaskActive">‚óè</div>
                    <label for="task_title" class="task-title">Main Task:</label>
                    <input type="text" id="task_title" name="task_title" required placeholder="e.g., Code a user interface">
                    <br><br>
                    <!-- Hidden inputs for task and subtask duration (in seconds) -->
                    <input type="hidden" id="task_duration" name="task_duration" value="0">
                    <input type="hidden" id="subtasks_data" name="subtasks_data" value="[]">
                    <div class="timer" id="timerDisplay">00:00:00</div>
                    <div>
                        <button type="button" class="button" id="startButton">Start</button>
                        <button type="button" class="button" id="pauseButton" disabled>Pause</button>
                        <button type="button" class="button" id="resumeButton" disabled>Resume</button>
                        <button type="button" class="button" id="stopButton" disabled>Stop</button>
                        <button type="button" class="button" id="subtaskButton" disabled>Start Subtask</button>
                    </div>
                    
                    <!-- Subtask section (initially hidden) -->
                    <div class="subtask-container" id="subtaskContainer">
                        <label for="subtask_title" class="subtask-title">Subtask:</label>
                        <input type="text" id="subtask_title" required placeholder="e.g., Research API endpoints">
                        <div class="subtask-timer" id="subtaskTimerDisplay">00:00:00</div>
                        <div>
                            <button type="button" class="button" id="startSubtaskButton">Start</button>
                            <button type="button" class="button" id="pauseSubtaskButton" disabled>Pause</button>
                            <button type="button" class="button" id="resumeSubtaskButton" disabled>Resume</button>
                            <button type="button" class="button" id="completeSubtaskButton" disabled>Complete</button>
                            <button type="button" class="button" id="nestedSubtaskButton" disabled>Start Nested Subtask</button>
                        </div>
                    </div>
                    
                    <!-- Nested Subtask section (initially hidden) -->
                    <div class="subtask-container nested-subtask" id="nestedSubtaskContainer">
                        <label for="nested_subtask_title" class="subtask-title">Nested Subtask:</label>
                        <input type="text" id="nested_subtask_title" required placeholder="e.g., Research specific API endpoint">
                        <div class="subtask-timer" id="nestedSubtaskTimerDisplay">00:00:00</div>
                        <div>
                            <button type="button" class="button" id="startNestedSubtaskButton">Start</button>
                            <button type="button" class="button" id="pauseNestedSubtaskButton" disabled>Pause</button>
                            <button type="button" class="button" id="resumeNestedSubtaskButton" disabled>Resume</button>
                            <button type="button" class="button" id="completeNestedSubtaskButton" disabled>Complete</button>
                        </div>
                    </div>
                    
                    <!-- Current Subtasks List -->
                    <div class="subtask-list" id="currentSubtasksList">
                        <h3>Current Subtasks</h3>
                        <div id="subtasksContainer"></div>
                    </div>
                </div>
            </form>
        </div>
    </div>

    <!-- Task Comparison Modal -->
    <div id="comparison-modal" class="comparison-modal">
        <div class="modal-content">
            <h3>Which task is more important?</h3>
            <div class="comparison-tasks">
                <div id="task1" class="comparison-task">Task 1</div>
                <div id="task2" class="comparison-task">Task 2</div>
            </div>
            <div class="comparison-buttons">
                <button type="button" id="task1-important">Task 1 is more important</button>
                <button type="button" id="task2-important">Task 2 is more important</button>
            </div>
        </div>
    </div>

    <!-- Metrics Section -->
    <h2>Metrics</h2>
    <div class="metrics">
        <p>Total tasks completed: {{ total_tasks }}</p>
        <p>Total time today: 
            <span class="formatted-time">({{ daily_total|default:0|floatformat:0|time_format }})</span>
        </p>
        <p>Total time this week: 
            <span class="formatted-time">({{ weekly_total|default:0|floatformat:0|time_format }})</span>
        </p>
    </div>

    <!-- Completed Tasks -->
    <h2>Completed Tasks</h2>
    <div class="task-list">
        <ul>
            {% for task in tasks %}
                <li id="task-{{ task.id }}">
                    <div class="task-details">
                        <span class="task-title-display">{{ task.title }}</span>
                        <span class="task-duration">{{ task.duration.total_seconds|floatformat:0 }} seconds</span>
                    </div>
                    
                    <!-- Subtasks section (if any) -->
                    {% if task.subtasks.all %}
                    <div class="subtasks-section has-subtasks" id="subtasks-{{ task.id }}">
                        <h4>Subtasks: <button type="button" class="toggle-subtasks-btn" data-task-id="{{ task.id }}">Show/Hide</button></h4>
                        <ul class="subtasks-list" id="subtasks-list-{{ task.id }}">
                            {% for subtask in task.subtasks.all %}
                                <li>{{ subtask.title }} - {{ subtask.duration.total_seconds|floatformat:0 }} seconds</li>
                            {% endfor %}
                        </ul>
                    </div>
                    {% endif %}
                </li>
            {% empty %}
                <li>No tasks yet.</li>
            {% endfor %}
        </ul>
    </div>

    <a href="{% url 'home' %}" class="home-button">Home</a>
{% endblock %}

{% block scripts %}
<script>
// Global variables and DOM references
let selectedTask = null; // Added for task selection functionality
const timerDisplay = document.getElementById('timerDisplay');
const taskDurationInput = document.getElementById('task_duration');
const startButton = document.getElementById('startButton');
const pauseButton = document.getElementById('pauseButton');
const resumeButton = document.getElementById('resumeButton');
const stopButton = document.getElementById('stopButton');
const subtaskButton = document.getElementById('subtaskButton');
const mainTaskActiveIndicator = document.getElementById('mainTaskActive');

const subtaskTimerDisplay = document.getElementById('subtaskTimerDisplay');
const subtaskContainer = document.getElementById('subtaskContainer');
const nestedSubtaskContainer = document.getElementById('nestedSubtaskContainer');
const currentSubtasksList = document.getElementById('currentSubtasksList');
const startSubtaskButton = document.getElementById('startSubtaskButton');
const pauseSubtaskButton = document.getElementById('pauseSubtaskButton');
const resumeSubtaskButton = document.getElementById('resumeSubtaskButton');
const completeSubtaskButton = document.getElementById('completeSubtaskButton');
const nestedSubtaskButton = document.getElementById('nestedSubtaskButton');

const nestedSubtaskTimerDisplay = document.getElementById('nestedSubtaskTimerDisplay');
const startNestedSubtaskButton = document.getElementById('startNestedSubtaskButton');
const pauseNestedSubtaskButton = document.getElementById('pauseNestedSubtaskButton');
const resumeNestedSubtaskButton = document.getElementById('resumeNestedSubtaskButton');
const completeNestedSubtaskButton = document.getElementById('completeNestedSubtaskButton');

const subtasksDataInput = document.getElementById('subtasks_data');

// Constants for localStorage keys
const TIMER_START_KEY = 'wir_timer_start';
const TIMER_ELAPSED_KEY = 'wir_timer_elapsed';
const TIMER_STATE_KEY = 'wir_timer_state';
const TASK_TITLE_KEY = 'wir_task_title';
const SUBTASK_DATA_KEY = 'wir_subtask_data';
const CURRENT_SUBTASK_KEY = 'wir_current_subtask';
const SUBTASK_START_KEY = 'wir_subtask_start';
const SUBTASK_ELAPSED_KEY = 'wir_subtask_elapsed';
const SUBTASK_STATE_KEY = 'wir_subtask_state';
const NESTED_SUBTASK_START_KEY = 'wir_nested_subtask_start';
const NESTED_SUBTASK_ELAPSED_KEY = 'wir_nested_subtask_elapsed';
const NESTED_SUBTASK_STATE_KEY = 'wir_nested_subtask_state';
const CURRENT_NESTED_SUBTASK_KEY = 'wir_current_nested_subtask';
const SUBTASK_ID_COUNTER_KEY = 'wir_subtask_id_counter';

// Timer states
const TIMER_STATES = {
    STOPPED: 'stopped',
    RUNNING: 'running',
    PAUSED: 'paused'
};

// Global state variables
let timerInterval;
let subtaskTimerInterval;
let nestedSubtaskTimerInterval;
let elapsed = 0;
let subtaskElapsed = 0;
let nestedSubtaskElapsed = 0;
let subtasks = [];
let subtaskIdCounter = parseInt(localStorage.getItem(SUBTASK_ID_COUNTER_KEY) || '0');

// Function to toggle subtasks visibility for a task
function toggleTaskSubtasks(taskId) {
    const subtasksList = document.getElementById(`subtasks-list-${taskId}`);
    if (subtasksList) {
        // Simply toggle between display:none and display:block
        if (subtasksList.style.display === 'block') {
            subtasksList.style.display = 'none';
            subtasksList.classList.remove('subtasks-visible');
        } else {
            subtasksList.style.display = 'block';
            subtasksList.classList.add('subtasks-visible');
        }
    }
}

// Initialize timers from local storage
function initializeTimers() {
    const timerState = localStorage.getItem(TIMER_STATE_KEY);
    const taskTitle = localStorage.getItem(TASK_TITLE_KEY);
    const subtaskState = localStorage.getItem(SUBTASK_STATE_KEY);
    const subtaskData = localStorage.getItem(SUBTASK_DATA_KEY);
    const currentSubtask = localStorage.getItem(CURRENT_SUBTASK_KEY);
    
    // Restore main task
    if (taskTitle) {
        document.getElementById('task_title').value = taskTitle;
    }
    
    // Restore subtasks
    if (subtaskData) {
        try {
            subtasks = JSON.parse(subtaskData);
            updateSubtasksList();
            
            if (subtasks.length > 0) {
                currentSubtasksList.style.display = 'block';
            }
        } catch (e) {
            console.error('Error parsing subtasks data', e);
            subtasks = [];
        }
    }
    
    // Restore current subtask if any
    if (currentSubtask) {
        try {
            const subtaskInfo = JSON.parse(currentSubtask);
            document.getElementById('subtask_title').value = subtaskInfo.title;
            
            if (subtaskState === TIMER_STATES.RUNNING || subtaskState === TIMER_STATES.PAUSED) {
                subtaskContainer.style.display = 'block';
            }
        } catch (e) {
            console.error('Error parsing current subtask', e);
        }
    }
    
    // Handle main task timer state
    if (timerState === TIMER_STATES.RUNNING) {
        // If subtask is running, main task should be paused
        if (subtaskState === TIMER_STATES.RUNNING) {
            updateMainTaskState(TIMER_STATES.PAUSED);
        } else {
            // Otherwise resume main task
            const startTimestamp = parseInt(localStorage.getItem(TIMER_START_KEY));
            if (startTimestamp) {
                timerInterval = setInterval(updateTimer, 1000);
                updateMainTaskState(TIMER_STATES.RUNNING);
            }
        }
    } else if (timerState === TIMER_STATES.PAUSED) {
        elapsed = parseFloat(localStorage.getItem(TIMER_ELAPSED_KEY)) || 0;
        updateTimerDisplay();
        updateMainTaskState(TIMER_STATES.PAUSED);
    }
    
    // Handle subtask timer state
    if (subtaskState === TIMER_STATES.RUNNING) {
        const subtaskStartTime = parseInt(localStorage.getItem(SUBTASK_START_KEY));
        if (subtaskStartTime) {
            subtaskTimerInterval = setInterval(updateSubtaskTimer, 1000);
            updateSubtaskState(TIMER_STATES.RUNNING);
        }
    } else if (subtaskState === TIMER_STATES.PAUSED) {
        subtaskElapsed = parseFloat(localStorage.getItem(SUBTASK_ELAPSED_KEY)) || 0;
        updateSubtaskTimerDisplay();
        updateSubtaskState(TIMER_STATES.PAUSED);
    }
}

// Update main timer display
function updateTimerDisplay() {
    timerDisplay.textContent = formatTime(elapsed);
}

// Update subtask timer display
function updateSubtaskTimerDisplay() {
    subtaskTimerDisplay.textContent = formatTime(subtaskElapsed);
}

// Format time as HH:MM:SS
function formatTime(seconds) {
    let hours = Math.floor(seconds / 3600);
    let minutes = Math.floor((seconds % 3600) / 60);
    let secs = Math.floor(seconds % 60);
    return String(hours).padStart(2, '0') + ':' +
           String(minutes).padStart(2, '0') + ':' +
           String(secs).padStart(2, '0');
}

// Update main task timer
function updateTimer() {
    const now = Date.now();
    elapsed = parseFloat(localStorage.getItem(TIMER_ELAPSED_KEY)) || 0;
    const startTime = parseInt(localStorage.getItem(TIMER_START_KEY));
    
    if (startTime) {
        elapsed = elapsed + (now - startTime) / 1000;
        localStorage.setItem(TIMER_ELAPSED_KEY, elapsed.toString());
        localStorage.setItem(TIMER_START_KEY, now.toString());
    }
    
    updateTimerDisplay();
}

// Update subtask timer
function updateSubtaskTimer() {
    const now = Date.now();
    subtaskElapsed = parseFloat(localStorage.getItem(SUBTASK_ELAPSED_KEY)) || 0;
    const startTime = parseInt(localStorage.getItem(SUBTASK_START_KEY));
    
    if (startTime) {
        subtaskElapsed = subtaskElapsed + (now - startTime) / 1000;
        localStorage.setItem(SUBTASK_ELAPSED_KEY, subtaskElapsed.toString());
        localStorage.setItem(SUBTASK_START_KEY, now.toString());
    }
    
    updateSubtaskTimerDisplay();
}

// Update nested subtask timer
function updateNestedSubtaskTimer() {
    const now = Date.now();
    nestedSubtaskElapsed = parseFloat(localStorage.getItem(NESTED_SUBTASK_ELAPSED_KEY)) || 0;
    const startTime = parseInt(localStorage.getItem(NESTED_SUBTASK_START_KEY));
    
    if (startTime) {
        nestedSubtaskElapsed = nestedSubtaskElapsed + (now - startTime) / 1000;
        localStorage.setItem(NESTED_SUBTASK_ELAPSED_KEY, nestedSubtaskElapsed.toString());
        localStorage.setItem(NESTED_SUBTASK_START_KEY, now.toString());
    }
    
    nestedSubtaskTimerDisplay.textContent = formatTime(nestedSubtaskElapsed);
}

// Update main task button state
function updateMainTaskState(state) {
    switch(state) {
        case TIMER_STATES.RUNNING:
            startButton.disabled = true;
            pauseButton.disabled = false;
            resumeButton.disabled = true;
            stopButton.disabled = false;
            subtaskButton.disabled = false;
            mainTaskActiveIndicator.classList.add('active');
            break;
        case TIMER_STATES.PAUSED:
            startButton.disabled = true;
            pauseButton.disabled = true;
            resumeButton.disabled = false;
            stopButton.disabled = false;
            subtaskButton.disabled = true;
            mainTaskActiveIndicator.classList.remove('active');
            break;
        case TIMER_STATES.STOPPED:
        default:
            startButton.disabled = false;
            pauseButton.disabled = true;
            resumeButton.disabled = true;
            stopButton.disabled = true;
            subtaskButton.disabled = true;
            mainTaskActiveIndicator.classList.remove('active');
            break;
    }
}

// Update subtask button state
function updateSubtaskState(state) {
    switch(state) {
        case TIMER_STATES.RUNNING:
            startSubtaskButton.disabled = true;
            pauseSubtaskButton.disabled = false;
            resumeSubtaskButton.disabled = true;
            completeSubtaskButton.disabled = false;
            nestedSubtaskButton.disabled = false;
            break;
        case TIMER_STATES.PAUSED:
            startSubtaskButton.disabled = true;
            pauseSubtaskButton.disabled = true;
            resumeSubtaskButton.disabled = false;
            completeSubtaskButton.disabled = false;
            nestedSubtaskButton.disabled = true;
            break;
        case TIMER_STATES.STOPPED:
        default:
            startSubtaskButton.disabled = false;
            pauseSubtaskButton.disabled = true;
            resumeSubtaskButton.disabled = true;
            completeSubtaskButton.disabled = true;
            nestedSubtaskButton.disabled = true;
            break;
    }
}

// Update nested subtask button state
function updateNestedSubtaskState(state) {
    switch(state) {
        case TIMER_STATES.RUNNING:
            startNestedSubtaskButton.disabled = true;
            pauseNestedSubtaskButton.disabled = false;
            resumeNestedSubtaskButton.disabled = true;
            completeNestedSubtaskButton.disabled = false;
            break;
        case TIMER_STATES.PAUSED:
            startNestedSubtaskButton.disabled = true;
            pauseNestedSubtaskButton.disabled = true;
            resumeNestedSubtaskButton.disabled = false;
            completeNestedSubtaskButton.disabled = false;
            break;
        case TIMER_STATES.STOPPED:
        default:
            startNestedSubtaskButton.disabled = false;
            pauseNestedSubtaskButton.disabled = true;
            resumeNestedSubtaskButton.disabled = true;
            completeNestedSubtaskButton.disabled = true;
            break;
    }
}

// Update the subtasks list in the UI
function updateSubtasksList() {
    const container = document.getElementById('subtasksContainer');
    container.innerHTML = '';
    
    subtasks.forEach(subtask => {
        const subtaskElement = document.createElement('div');
        subtaskElement.className = 'subtask-item';
        
        // Check if this subtask has nested subtasks
        const hasNestedSubtasks = subtask.nestedSubtasks && subtask.nestedSubtasks.length > 0;
        const nestedSubtasksInfo = hasNestedSubtasks ? 
            `<div class="task-hierarchy">
                ${subtask.nestedSubtasks.map(nested => 
                    `<div class="subtask-item">
                        <span class="subtask-name">${nested.title}</span>
                        <span class="subtask-duration">${formatTime(nested.duration)}</span>
                    </div>`
                ).join('')}
            </div>` : '';
        
        subtaskElement.innerHTML = `
            <span class="subtask-name ${hasNestedSubtasks ? 'parent-task' : ''}">${subtask.title}</span>
            <span class="subtask-duration">${formatTime(subtask.duration)}</span>
            ${nestedSubtasksInfo}
        `;
        container.appendChild(subtaskElement);
    });
    
    // Update the hidden input with the subtasks data
    subtasksDataInput.value = JSON.stringify(subtasks);
    localStorage.setItem(SUBTASK_DATA_KEY, JSON.stringify(subtasks));
}
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

// Main Task Button Event Listeners
startButton.addEventListener('click', function() {
    const taskTitle = document.getElementById('task_title').value;
    localStorage.setItem(TASK_TITLE_KEY, taskTitle);
    
    elapsed = 0;
    const now = Date.now();
    localStorage.setItem(TIMER_START_KEY, now.toString());
    localStorage.setItem(TIMER_ELAPSED_KEY, '0');
    localStorage.setItem(TIMER_STATE_KEY, TIMER_STATES.RUNNING);
    
    timerInterval = setInterval(updateTimer, 1000);
    updateMainTaskState(TIMER_STATES.RUNNING);
});

pauseButton.addEventListener('click', function() {
    clearInterval(timerInterval);
    updateTimer(); // Update one last time
    localStorage.setItem(TIMER_STATE_KEY, TIMER_STATES.PAUSED);
    updateMainTaskState(TIMER_STATES.PAUSED);
});

resumeButton.addEventListener('click', function() {
    const now = Date.now();
    localStorage.setItem(TIMER_START_KEY, now.toString());
    localStorage.setItem(TIMER_STATE_KEY, TIMER_STATES.RUNNING);
    
    timerInterval = setInterval(updateTimer, 1000);
    updateMainTaskState(TIMER_STATES.RUNNING);
});
// Function to add a completed task to the list
function addCompletedTask(title, duration, subtasks = []) {
    // Create completed task object
    const completedTask = {
        id: Date.now(),
        title: title,
        duration: duration,
        timestamp: new Date().toISOString(),
        subtasks: subtasks
    };
    
    // Send task data to server via AJAX
    const csrfToken = getCookie('csrftoken');
    fetch('{% url "wir_view" %}', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrfToken
        },
        body: JSON.stringify({
            task_title: completedTask.title,
            task_duration: completedTask.duration,
            subtasks_data: JSON.stringify(completedTask.subtasks)
        })
    })
    .then(response => response.json())
    .then(data => {
        console.log('Task saved:', data);
        
        // Add the task to the UI immediately
        addTaskToCompletedList(completedTask);
        
        // Update metrics
        updateMetricsDisplay(data.daily_total, data.weekly_total, data.total_tasks);
    })
    .catch(error => {
        console.error('Error saving task:', error);
        // Still add to UI even if server fails
        addTaskToCompletedList(completedTask);
    });
}

// Reset the task UI after completion
function resetTaskUI() {
    // Clear task title
    document.getElementById('task_title').value = '';
    
    // Reset timer display
    elapsed = 0;
    updateTimerDisplay();
    
    // Clear subtasks UI
    subtasks = [];
    updateSubtasksList();
    
    // Hide subtask containers
    subtaskContainer.style.display = 'none';
    nestedSubtaskContainer.style.display = 'none';
    currentSubtasksList.style.display = 'none';
    
    // Reset button states
    updateMainTaskState(TIMER_STATES.STOPPED);
}

// Clear localStorage timer data
function clearTimerLocalStorage() {
    localStorage.removeItem(TIMER_START_KEY);
    localStorage.removeItem(TIMER_ELAPSED_KEY);
    localStorage.removeItem(TIMER_STATE_KEY);
    localStorage.removeItem(TASK_TITLE_KEY);
    localStorage.removeItem(SUBTASK_DATA_KEY);
    localStorage.removeItem(SUBTASK_START_KEY);
    localStorage.removeItem(SUBTASK_ELAPSED_KEY);
    localStorage.removeItem(SUBTASK_STATE_KEY);
    localStorage.removeItem(CURRENT_SUBTASK_KEY);
    localStorage.removeItem(NESTED_SUBTASK_START_KEY);
    localStorage.removeItem(NESTED_SUBTASK_ELAPSED_KEY);
    localStorage.removeItem(NESTED_SUBTASK_STATE_KEY);
    localStorage.removeItem(CURRENT_NESTED_SUBTASK_KEY);
}

// Replace the stop button event handler
stopButton.addEventListener('click', function() {
    // First get reference to PRIORITY_TASKS_KEY to ensure it's defined in this scope
    const PRIORITY_TASKS_KEY = 'wir_priority_tasks';
    
    // Process selected task if exists
    if (selectedTask) {
        const priority = selectedTask.priority;
        const taskId = parseInt(selectedTask.id);
        
        // Find and remove from priority lists in localStorage
        const savedTasks = localStorage.getItem(PRIORITY_TASKS_KEY);
        if (savedTasks) {
            try {
                const allTasks = JSON.parse(savedTasks);
                if (allTasks[priority]) {
                    allTasks[priority] = allTasks[priority].filter(t => t.id !== taskId);
                    localStorage.setItem(PRIORITY_TASKS_KEY, JSON.stringify(allTasks));
                    
                    // Update the global priorityTasks variable used for task comparisons
                    // This ensures deleted tasks aren't used in future comparisons
                    // We need to use window object to access the variable from the DOMContentLoaded scope
                    if (window.priorityTasks && window.priorityTasks[priority]) {
                        window.priorityTasks[priority] = window.priorityTasks[priority].filter(t => t.id !== taskId);
                    }
                    
                    // Update UI immediately
                    const taskList = document.getElementById(`${priority}-priority-tasks`);
                    if (taskList) {
                        const taskElement = taskList.querySelector(`li[data-task-id="${taskId}"]`);
                        if (taskElement) {
                            taskElement.remove();
                        }
                    }
                }
            } catch (e) {
                console.error('Error updating tasks:', e);
            }
        }
        
        // Reset selected task
        selectedTask = null;
        
        // Remove selected-task class from any task items
        document.querySelectorAll('.task-item').forEach(item => {
            item.classList.remove('selected-task');
        });
    }
    
    // Stop timers
    clearInterval(timerInterval);
    clearInterval(subtaskTimerInterval);
    updateTimer();
    
    // Get task data
    const taskTitle = document.getElementById('task_title').value || 'Unnamed Task';
    const taskDuration = Math.floor(elapsed);
    
    // Process subtasks
    const allSubtasks = [];
    subtasks.forEach(subtask => {
        allSubtasks.push({
            title: subtask.title,
            duration: Math.floor(subtask.duration || 0),
            parentId: null
        });
    });
    
    // Update form input for form submission
    subtasksDataInput.value = JSON.stringify(allSubtasks);
    
    // Add to completed tasks
    addCompletedTask(taskTitle, taskDuration, allSubtasks);
    
    // Reset UI and timer
    resetTaskUI();
    
    // Clear localStorage items
    clearTimerLocalStorage();
    
    // Return false to prevent form submission
    return false;
});

// Subtask Button Event Listeners
subtaskButton.addEventListener('click', function() {
    // Pause the main task
    clearInterval(timerInterval);
    updateTimer(); // Update one last time
    localStorage.setItem(TIMER_STATE_KEY, TIMER_STATES.PAUSED);
    updateMainTaskState(TIMER_STATES.PAUSED);
    
    // Show the subtask container
    subtaskContainer.style.display = 'block';
    
    // IMPORTANT FIX: Reset subtask button states
    startSubtaskButton.disabled = false;
    pauseSubtaskButton.disabled = true;
    resumeSubtaskButton.disabled = true;
    completeSubtaskButton.disabled = true;
    nestedSubtaskButton.disabled = true;
    
    document.getElementById('subtask_title').focus();
});

// Nested Subtask Button Event Listeners
nestedSubtaskButton.addEventListener('click', function() {
    // Pause the subtask
    clearInterval(subtaskTimerInterval);
    updateSubtaskTimer(); // Update one last time
    localStorage.setItem(SUBTASK_STATE_KEY, TIMER_STATES.PAUSED);
    updateSubtaskState(TIMER_STATES.PAUSED);
    
    // Show the nested subtask container
    nestedSubtaskContainer.style.display = 'block';
    document.getElementById('nested_subtask_title').focus();
});

startSubtaskButton.addEventListener('click', function() {
    const subtaskTitle = document.getElementById('subtask_title').value;
    if (!subtaskTitle) {
        alert('Please enter a subtask title');
        return;
    }
    
    // Save current subtask info with unique ID
    const currentSubtask = {
        id: subtaskIdCounter,
        title: subtaskTitle,
        startTime: new Date().toISOString()
    };
    
    // Increment counter after using it
    subtaskIdCounter++;
    localStorage.setItem(SUBTASK_ID_COUNTER_KEY, subtaskIdCounter.toString());
    
    localStorage.setItem(CURRENT_SUBTASK_KEY, JSON.stringify(currentSubtask));
    
    // Start the subtask timer
    subtaskElapsed = 0;
    const now = Date.now();
    localStorage.setItem(SUBTASK_START_KEY, now.toString());
    localStorage.setItem(SUBTASK_ELAPSED_KEY, '0');
    localStorage.setItem(SUBTASK_STATE_KEY, TIMER_STATES.RUNNING);
    
    subtaskTimerInterval = setInterval(updateSubtaskTimer, 1000);
    updateSubtaskState(TIMER_STATES.RUNNING);
});

pauseSubtaskButton.addEventListener('click', function() {
    clearInterval(subtaskTimerInterval);
    updateSubtaskTimer(); // Update one last time
    localStorage.setItem(SUBTASK_STATE_KEY, TIMER_STATES.PAUSED);
    updateSubtaskState(TIMER_STATES.PAUSED);
});

resumeSubtaskButton.addEventListener('click', function() {
    const now = Date.now();
    localStorage.setItem(SUBTASK_START_KEY, now.toString());
    localStorage.setItem(SUBTASK_STATE_KEY, TIMER_STATES.RUNNING);
    
    subtaskTimerInterval = setInterval(updateSubtaskTimer, 1000);
    updateSubtaskState(TIMER_STATES.RUNNING);
});

completeSubtaskButton.addEventListener('click', function() {
    // Stop the subtask timer
    clearInterval(subtaskTimerInterval);
    updateSubtaskTimer(); // Update one last time
    
    // Save the completed subtask
    const currentSubtaskData = localStorage.getItem(CURRENT_SUBTASK_KEY);
    if (currentSubtaskData) {
        try {
            const subtaskInfo = JSON.parse(currentSubtaskData);
            const completedSubtask = {
                id: subtaskInfo.id,
                title: subtaskInfo.title,
                duration: subtaskElapsed,
                completed: new Date().toISOString()
            };
            
            subtasks.push(completedSubtask);
            updateSubtasksList();
            
            // Show the subtasks list if this is the first subtask
            if (subtasks.length === 1) {
                currentSubtasksList.style.display = 'block';
            }
            
        } catch (e) {
            console.error('Error processing subtask data', e);
        }
    }
    
    // Clear subtask form and hide it
    document.getElementById('subtask_title').value = '';
    subtaskContainer.style.display = 'none';
    subtaskElapsed = 0;
    updateSubtaskTimerDisplay();
    
    // Clear subtask state from localStorage
    localStorage.removeItem(SUBTASK_START_KEY);
    localStorage.removeItem(SUBTASK_ELAPSED_KEY);
    localStorage.removeItem(SUBTASK_STATE_KEY);
    localStorage.removeItem(CURRENT_SUBTASK_KEY);
    
    // Resume the main task
    const now = Date.now();
    localStorage.setItem(TIMER_START_KEY, now.toString());
    localStorage.setItem(TIMER_STATE_KEY, TIMER_STATES.RUNNING);
    
    timerInterval = setInterval(updateTimer, 1000);
    updateMainTaskState(TIMER_STATES.RUNNING);
    
    // IMPORTANT ADDITION: Make subtask button enabled again
    subtaskButton.disabled = false;
});

startNestedSubtaskButton.addEventListener('click', function() {
    const nestedSubtaskTitle = document.getElementById('nested_subtask_title').value;
    if (!nestedSubtaskTitle) {
        alert('Please enter a nested subtask title');
        return;
    }
    
    // Get parent subtask info
    const currentSubtaskData = localStorage.getItem(CURRENT_SUBTASK_KEY);
    if (!currentSubtaskData) {
        alert('Parent subtask information not found');
        return;
    }
    
    const parentSubtask = JSON.parse(currentSubtaskData);
    
    // Save current nested subtask info with unique ID
    const currentNestedSubtask = {
        id: subtaskIdCounter,
        title: nestedSubtaskTitle,
        startTime: new Date().toISOString(),
        parentId: parentSubtask.id
    };
    
    // Increment counter after using it
    subtaskIdCounter++;
    localStorage.setItem(SUBTASK_ID_COUNTER_KEY, subtaskIdCounter.toString());
    
    localStorage.setItem(CURRENT_NESTED_SUBTASK_KEY, JSON.stringify(currentNestedSubtask));
    
    // Start the nested subtask timer
    nestedSubtaskElapsed = 0;
    const now = Date.now();
    localStorage.setItem(NESTED_SUBTASK_START_KEY, now.toString());
    localStorage.setItem(NESTED_SUBTASK_ELAPSED_KEY, '0');
    localStorage.setItem(NESTED_SUBTASK_STATE_KEY, TIMER_STATES.RUNNING);
    
    nestedSubtaskTimerInterval = setInterval(updateNestedSubtaskTimer, 1000);
    updateNestedSubtaskState(TIMER_STATES.RUNNING);
});

pauseNestedSubtaskButton.addEventListener('click', function() {
    clearInterval(nestedSubtaskTimerInterval);
    updateNestedSubtaskTimer(); // Update one last time
    localStorage.setItem(NESTED_SUBTASK_STATE_KEY, TIMER_STATES.PAUSED);
    updateNestedSubtaskState(TIMER_STATES.PAUSED);
});

resumeNestedSubtaskButton.addEventListener('click', function() {
    const now = Date.now();
    localStorage.setItem(NESTED_SUBTASK_START_KEY, now.toString());
    localStorage.setItem(NESTED_SUBTASK_STATE_KEY, TIMER_STATES.RUNNING);
    
    nestedSubtaskTimerInterval = setInterval(updateNestedSubtaskTimer, 1000);
    updateNestedSubtaskState(TIMER_STATES.RUNNING);
});

completeNestedSubtaskButton.addEventListener('click', function() {
    // Stop the nested subtask timer
    clearInterval(nestedSubtaskTimerInterval);
    updateNestedSubtaskTimer(); // Update one last time
    
    // Save the completed nested subtask
    const currentNestedSubtaskData = localStorage.getItem(CURRENT_NESTED_SUBTASK_KEY);
    const currentSubtaskData = localStorage.getItem(CURRENT_SUBTASK_KEY);
    
    if (currentNestedSubtaskData && currentSubtaskData) {
        try {
            const nestedSubtaskInfo = JSON.parse(currentNestedSubtaskData);
            const currentSubtaskInfo = JSON.parse(currentSubtaskData);
            
            const completedNestedSubtask = {
                id: nestedSubtaskInfo.id,
                title: nestedSubtaskInfo.title,
                duration: nestedSubtaskElapsed,
                completed: new Date().toISOString(),
                parentId: nestedSubtaskInfo.parentId
            };
            
            // Find the parent subtask in the subtasks array to add this nested subtask
            for (let i = 0; i < subtasks.length; i++) {
                if (subtasks[i].id === completedNestedSubtask.parentId) {
                    // Initialize nestedSubtasks array if it doesn't exist
                    if (!subtasks[i].nestedSubtasks) {
                        subtasks[i].nestedSubtasks = [];
                    }
                    subtasks[i].nestedSubtasks.push(completedNestedSubtask);
                    break;
                }
            }
            
            updateSubtasksList();
            
        } catch (e) {
            console.error('Error processing nested subtask data', e);
        }
    }
    
    // Clear nested subtask form and hide it
    document.getElementById('nested_subtask_title').value = '';
    nestedSubtaskContainer.style.display = 'none';
    nestedSubtaskElapsed = 0;
    nestedSubtaskTimerDisplay.textContent = formatTime(0);
    
    // Clear nested subtask state from localStorage
    localStorage.removeItem(NESTED_SUBTASK_START_KEY);
    localStorage.removeItem(NESTED_SUBTASK_ELAPSED_KEY);
    localStorage.removeItem(NESTED_SUBTASK_STATE_KEY);
    localStorage.removeItem(CURRENT_NESTED_SUBTASK_KEY);
    
    // Resume the subtask
    const now = Date.now();
    localStorage.setItem(SUBTASK_START_KEY, now.toString());
    localStorage.setItem(SUBTASK_STATE_KEY, TIMER_STATES.RUNNING);
    
    subtaskTimerInterval = setInterval(updateSubtaskTimer, 1000);
    updateSubtaskState(TIMER_STATES.RUNNING);
});

// Add event listeners to toggle subtask buttons
document.addEventListener('click', function(e) {
    if (e.target.classList.contains('toggle-subtasks-btn')) {
        const taskId = e.target.getAttribute('data-task-id');
        toggleTaskSubtasks(taskId);
    }
});

// Initialize timers on page load
initializeTimers();

// Handle page unload
window.addEventListener('beforeunload', function() {
    // Update the main task timer
    if (localStorage.getItem(TIMER_STATE_KEY) === TIMER_STATES.RUNNING) {
        updateTimer();
    }
    
    // Update the subtask timer
    if (localStorage.getItem(SUBTASK_STATE_KEY) === TIMER_STATES.RUNNING) {
        updateSubtaskTimer();
    }
    
    // Update the nested subtask timer
    if (localStorage.getItem(NESTED_SUBTASK_STATE_KEY) === TIMER_STATES.RUNNING) {
        updateNestedSubtaskTimer();
    }
});

// =================================================================
// NEW PRIORITY TASK MANAGEMENT SYSTEM
// =================================================================

// Priority task management
// Define priorityTasks in the global scope first
window.priorityTasks = {
    high: [],
    medium: [],
    low: []
};

document.addEventListener('DOMContentLoaded', function() {
    // Initialize task priorities from localStorage if available
    const PRIORITY_TASKS_KEY = 'wir_priority_tasks';

    // Load saved priority tasks into our global window.priorityTasks object
    const savedTasks = localStorage.getItem(PRIORITY_TASKS_KEY);
    if (savedTasks) {
        try {
            const parsedTasks = JSON.parse(savedTasks);
            window.priorityTasks = parsedTasks;
        } catch (e) {
            console.error('Error loading saved priority tasks:', e);
        }
    }

    // DOM elements
    const addTaskBtn = document.getElementById('add-task-btn');
    const newTaskInput = document.getElementById('new-task-title');
    const taskPrioritySelect = document.getElementById('task-priority');
    const highPriorityList = document.getElementById('high-priority-tasks');
    const mediumPriorityList = document.getElementById('medium-priority-tasks');
    const lowPriorityList = document.getElementById('low-priority-tasks');
    const comparisonModal = document.getElementById('comparison-modal');
    const task1Element = document.getElementById('task1');
    const task2Element = document.getElementById('task2');
    const task1Button = document.getElementById('task1-important');
    const task2Button = document.getElementById('task2-important');

    // Render initial task lists
    renderAllTaskLists();

    // Add new task function
    function addTask() {
        const taskTitle = newTaskInput.value.trim();
        const priority = taskPrioritySelect.value;
        
        if (!taskTitle) {
            alert('Please enter a task title');
            return;
        }
        
        const newTask = {
            id: Date.now(),
            title: taskTitle,
            priority: priority,
            createdAt: new Date()
        };
        
        // Add the task to its priority list
        window.priorityTasks[priority].push(newTask);
        
        // If there are other tasks in this priority level, start comparison
        if (window.priorityTasks[priority].length > 1) {
            // Get up to 4 existing tasks to compare with
            const existingTasks = window.priorityTasks[priority].slice(0, -1).slice(-4);
            if (existingTasks.length > 0) {
                startComparisons(newTask, existingTasks);
            }
        }
        
        // Clear the input
        newTaskInput.value = '';
        
        // Save tasks to localStorage
        saveTasksToLocalStorage();
        
        // Update UI
        renderAllTaskLists();
    }

    // Start task comparisons
    function startComparisons(newTask, tasksToCompare) {
        let currentComparison = 0;
        let tasksToProcess = [...tasksToCompare];
        
        // Function to process next comparison or finish
        function processNextComparison() {
            if (currentComparison < tasksToProcess.length) {
                showComparison(newTask, tasksToProcess[currentComparison], (isNewTaskMoreImportant) => {
                    if (isNewTaskMoreImportant) {
                        // If new task is more important, swap positions
                        const priority = newTask.priority;
                        const tasks = window.priorityTasks[priority];
                        
                        // Find indices
                        const newTaskIndex = tasks.findIndex(t => t.id === newTask.id);
                        const compareTaskIndex = tasks.findIndex(t => t.id === tasksToProcess[currentComparison].id);
                        
                        // Only swap if the new task is after the comparison task
                        if (newTaskIndex > compareTaskIndex) {
                            // Remove the new task
                            tasks.splice(newTaskIndex, 1);
                            // Insert it before the comparison task
                            tasks.splice(compareTaskIndex, 0, newTask);
                            // Update in the main object
                            window.priorityTasks[priority] = tasks;
                            // Save changes
                            saveTasksToLocalStorage();
                            // Update UI
                            renderAllTaskLists();
                        }
                    }
                    
                    // Move to next comparison
                    currentComparison++;
                    processNextComparison();
                });
            }
        }
        
        // Start the comparison process
        processNextComparison();
    }

    // Show comparison modal between two tasks
    function showComparison(task1, task2, callback) {
        // Set the task titles in the modal
        task1Element.textContent = task1.title;
        task2Element.textContent = task2.title;
        
        // Show the modal
        comparisonModal.style.display = 'block';
        
        // Set up one-time event handlers
        const task1Handler = function() {
            // Task 1 (new task) is more important
            comparisonModal.style.display = 'none';
            task1Button.removeEventListener('click', task1Handler);
            task2Button.removeEventListener('click', task2Handler);
            callback(true);
        };
        
        const task2Handler = function() {
            // Task 2 (existing task) is more important
            comparisonModal.style.display = 'none';
            task1Button.removeEventListener('click', task1Handler);
            task2Button.removeEventListener('click', task2Handler);
            callback(false);
        };
        
        // Add event listeners
        task1Button.addEventListener('click', task1Handler);
        task2Button.addEventListener('click', task2Handler);
    }

    // Render all task lists
    function renderAllTaskLists() {
        renderTaskList(highPriorityList, window.priorityTasks.high);
        renderTaskList(mediumPriorityList, window.priorityTasks.medium);
        renderTaskList(lowPriorityList, window.priorityTasks.low);
    }

    // Render a single task list - MODIFIED to add data attributes and make tasks selectable
    function renderTaskList(listElement, tasks) {
        // Clear the list
        listElement.innerHTML = '';
        
        // Add tasks to the list
        tasks.forEach(task => {
            const li = document.createElement('li');
            li.className = 'task-item';
            li.textContent = task.title;
            li.dataset.taskId = task.id;
            li.dataset.priority = task.priority || listElement.id.split('-')[0]; // Extract priority from list ID
            
            // Add delete button
            const deleteBtn = document.createElement('span');
            deleteBtn.textContent = '‚úï';
            deleteBtn.className = 'delete-task';
            deleteBtn.style.float = 'right';
            deleteBtn.style.cursor = 'pointer';
            deleteBtn.style.color = '#dc3545';
            deleteBtn.dataset.taskId = task.id;
            deleteBtn.dataset.priority = task.priority || listElement.id.split('-')[0];
            
            li.appendChild(deleteBtn);
            listElement.appendChild(li);
        });
    }

    // Delete a task
    function deleteTask(taskId, priority) {
        // Find the task index
        const taskIndex = window.priorityTasks[priority].findIndex(t => t.id === parseInt(taskId));
        
        if (taskIndex !== -1) {
            // Remove the task
            window.priorityTasks[priority].splice(taskIndex, 1);
            // Save changes
            saveTasksToLocalStorage();
            // Update UI
            renderAllTaskLists();
        }
    }

    // Save all tasks to localStorage
    function saveTasksToLocalStorage() {
        localStorage.setItem(PRIORITY_TASKS_KEY, JSON.stringify(window.priorityTasks));
    }

    // Make task items selectable and update the main task field
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('task-item') && !e.target.classList.contains('delete-task')) {
            // Set visual selected state
            document.querySelectorAll('.task-item').forEach(item => {
                item.classList.remove('selected-task');
            });
            e.target.classList.add('selected-task');
            
            // Update the main task input
            const taskTitle = e.target.textContent.replace('‚úï', '').trim();
            document.getElementById('task_title').value = taskTitle;
            
            // Store the selected task ID for deletion later
            selectedTask = {
                id: e.target.dataset.taskId,
                priority: e.target.dataset.priority
            };
        }
    });

    // Add event listeners
    addTaskBtn.addEventListener('click', addTask);
    
    // Add event listener for Enter key in the input field
    newTaskInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            addTask();
        }
    });
    
    // Event delegation for delete buttons
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('delete-task')) {
            const taskId = e.target.dataset.taskId;
            const priority = e.target.dataset.priority;
            deleteTask(taskId, priority);
        }
    });
});
</script>


{% endblock %}